# AWS KMS (Key Management Service) - Complete Guide

## Table of Contents
1. [KMS Fundamentals](#kms-fundamentals)
2. [KMS Key Types & Concepts](#kms-key-types--concepts)
3. [Creating & Managing KMS Keys](#creating--managing-kms-keys)
4. [Key Policies & Access Control](#key-policies--access-control)
5. [Encryption & Decryption Operations](#encryption--decryption-operations)
6. [Key Rotation & Lifecycle Management](#key-rotation--lifecycle-management)
7. [Integration with AWS Services](#integration-with-aws-services)
8. [Real-World Implementation Examples](#real-world-implementation-examples)
9. [Multi-Region Keys & Cross-Account Access](#multi-region-keys--cross-account-access)
10. [Monitoring, Auditing & Best Practices](#monitoring-auditing--best-practices)

---

## KMS Fundamentals

### What is AWS KMS?

#### Definition & Purpose
AWS Key Management Service (KMS) is a **managed service** that makes it easy to:
- **Create and control** cryptographic keys
- **Encrypt and decrypt** data across AWS services and applications
- **Audit key usage** through AWS CloudTrail
- **Meet compliance requirements** for data protection

#### Why Use KMS?
**Problems KMS Solves**:
1. **Key Management Complexity**: Manual key generation, storage, and rotation
2. **Security Risks**: Keys stored in application code or configuration files
3. **Compliance Requirements**: Need for auditable encryption key management
4. **Scalability Issues**: Managing keys across multiple services and regions
5. **Cost**: Expensive Hardware Security Modules (HSMs) for key protection

#### Core Benefits:
- **Centralized Key Management**: Single place to manage all encryption keys
- **Integration**: Native integration with 100+ AWS services
- **Security**: Keys never leave KMS unencrypted
- **Compliance**: FIPS 140-2 Level 2 validated HSMs
- **Audit Trail**: Complete logging of key usage
- **Cost-Effective**: Pay-per-use pricing model

### How KMS Works

#### High-Level Architecture:
```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   Application   │    │      AWS KMS     │    │      HSM        │
│   (Your Code)   │◄──►│   (API Layer)    │◄──►│  (Key Storage)  │
└─────────────────┘    └──────────────────┘    └─────────────────┘
         │                       │                       │
         │              ┌──────────────────┐            │
         └──────────────►│   CloudTrail     │◄───────────┘
                         │   (Audit Logs)   │
                         └──────────────────┘
```

#### Key Concepts:

**1. Customer Master Keys (CMKs) / KMS Keys**
- Primary resources in KMS
- Used to encrypt/decrypt data encryption keys (DEKs)
- Never leave KMS unencrypted
- Can be AWS managed or customer managed

**2. Data Encryption Keys (DEKs)**
- Used to encrypt actual data
- Generated by KMS but used outside KMS
- Encrypted by CMKs for secure storage

**3. Envelope Encryption**
- Two-tier encryption system
- Data encrypted with DEK
- DEK encrypted with CMK
- Provides performance and security benefits

#### Envelope Encryption Process:

```
Step 1: Generate Data Encryption Key (DEK)
┌─────────────┐    GenerateDataKey    ┌─────────────┐
│ Application │ ────────────────────► │    KMS      │
└─────────────┘                      └─────────────┘
                                            │
                                            ▼
                                    ┌─────────────┐
                                    │ Returns:    │
                                    │ - Plaintext │
                                    │   DEK       │
                                    │ - Encrypted │
                                    │   DEK       │
                                    └─────────────┘

Step 2: Encrypt Data with Plaintext DEK
┌─────────────┐    Encrypt Data      ┌─────────────┐
│ Application │ ────────────────────► │ Encrypted   │
│             │                      │ Data        │
└─────────────┘                      └─────────────┘

Step 3: Store Encrypted DEK with Encrypted Data
┌─────────────────────────────────────────────────┐
│              Stored Together                    │
│  ┌─────────────┐    ┌─────────────────────────┐ │
│  │ Encrypted   │    │     Encrypted Data      │ │
│  │    DEK      │    │   (Large Dataset)       │ │
│  └─────────────┘    └─────────────────────────┘ │
└─────────────────────────────────────────────────┘

Step 4: Decrypt Process (Reverse)
┌─────────────┐    Decrypt DEK       ┌─────────────┐
│ Application │ ────────────────────► │    KMS      │
│             │ ◄──────────────────── │             │
└─────────────┘    Plaintext DEK     └─────────────┘
       │
       ▼
┌─────────────┐    Decrypt Data      ┌─────────────┐
│ Application │ ────────────────────► │ Plaintext   │
│             │                      │ Data        │
└─────────────┘                      └─────────────┘
```

### KMS Security Model

#### Defense in Depth:
1. **Physical Security**: AWS data centers with multiple security layers
2. **Hardware Security**: FIPS 140-2 Level 2 validated HSMs
3. **Network Security**: VPC endpoints, TLS encryption in transit
4. **Access Control**: IAM policies and key policies
5. **Audit Logging**: CloudTrail logs all key operations
6. **Key Isolation**: Keys are logically isolated per AWS account

#### Key Security Features:
- **Keys never leave KMS unencrypted**
- **Automatic key rotation** (optional)
- **Key deletion protection** with waiting period
- **Cross-region replication** for disaster recovery
- **Integration with AWS CloudHSM** for dedicated hardware

---

## KMS Key Types & Concepts

### 1. Key Management Types

#### AWS Managed Keys
**Characteristics**:
- Created and managed by AWS services
- Automatic rotation every year
- No direct access to key policies
- Free to use (no monthly fee)
- Cannot be deleted

**Naming Convention**: `aws/service-name`

**Examples**:
```bash
# List AWS managed keys
aws kms list-keys --query 'Keys[?KeyManager==`AWS`]'

# Common AWS managed keys:
aws/s3          # S3 encryption
aws/ebs         # EBS volume encryption  
aws/rds         # RDS encryption
aws/lambda      # Lambda environment variables
aws/secretsmanager  # Secrets Manager
```

**Use Cases**:
- Default encryption for AWS services
- Quick setup without key management overhead
- Services that don't require custom key policies

#### Customer Managed Keys
**Characteristics**:
- Full control over key lifecycle
- Custom key policies and permissions
- Optional automatic rotation
- Monthly fee ($1/month per key)
- Can be scheduled for deletion

**Use Cases**:
- Custom access control requirements
- Cross-account access needs
- Compliance requirements for key ownership
- Integration with external applications

**Example Creation**:
```bash
# Create customer managed key
aws kms create-key \
  --description "Customer data encryption key" \
  --key-usage ENCRYPT_DECRYPT \
  --key-spec SYMMETRIC_DEFAULT
```

#### AWS Owned Keys
**Characteristics**:
- Owned and managed by AWS
- Used by AWS services internally
- Not visible in your account
- No charges or quotas
- Cannot be used directly

**Examples**: DynamoDB default encryption, S3 bucket keys

### 2. Key Specifications

#### Symmetric Keys (Default)
**Characteristics**:
- Same key for encryption and decryption
- AES-256 encryption algorithm
- Most common type for data encryption
- Used with envelope encryption

**Use Cases**:
- Data encryption (files, databases, etc.)
- AWS service integration
- Bulk data encryption

**Example**:
```bash
# Create symmetric key
aws kms create-key \
  --key-spec SYMMETRIC_DEFAULT \
  --key-usage ENCRYPT_DECRYPT \
  --description "Symmetric key for data encryption"
```

#### Asymmetric Keys
**Characteristics**:
- Different keys for encryption/decryption (public/private key pair)
- RSA or Elliptic Curve algorithms
- Public key can be shared
- Private key never leaves KMS

**Key Specifications**:
- **RSA_2048**: RSA with 2048-bit key
- **RSA_3072**: RSA with 3072-bit key  
- **RSA_4096**: RSA with 4096-bit key
- **ECC_NIST_P256**: Elliptic Curve P-256
- **ECC_NIST_P384**: Elliptic Curve P-384
- **ECC_NIST_P521**: Elliptic Curve P-521
- **ECC_SECG_P256K1**: Elliptic Curve secp256k1

**Use Cases**:
- Digital signatures
- Client-side encryption
- SSL/TLS certificate signing
- Blockchain applications

**Example**:
```bash
# Create asymmetric key for signing
aws kms create-key \
  --key-spec RSA_2048 \
  --key-usage SIGN_VERIFY \
  --description "RSA key for digital signatures"

# Create asymmetric key for encryption
aws kms create-key \
  --key-spec RSA_2048 \
  --key-usage ENCRYPT_DECRYPT \
  --description "RSA key for client-side encryption"
```

### 3. Key States

#### Key Lifecycle States:

```
Creating ──► Enabled ──► Disabled ──► PendingDeletion ──► Deleted
    │           │           │              │
    │           │           │              │
    │           │           └──────────────┘
    │           │              (7-30 days)
    │           │
    │           └──► PendingImport ──► Enabled
    │                     │
    │                     └──► Expired
    │
    └──► PendingReplicaDeletion ──► Deleted
```

**State Descriptions**:

**1. Creating**
- Key is being created
- Cannot be used for cryptographic operations
- Temporary state

**2. Enabled**
- Key is active and ready for use
- Can perform all cryptographic operations
- Default state for new keys

**3. Disabled**
- Key exists but cannot be used
- Can be re-enabled
- Useful for temporary suspension

**4. PendingDeletion**
- Key scheduled for deletion
- Waiting period: 7-30 days (default 30)
- Can be cancelled during waiting period
- Cannot be used for operations

**5. PendingImport**
- Key created but key material not imported
- For keys with external key material
- Must import material to become enabled

**6. Expired**
- Imported key material has expired
- Can import new material to re-enable

**Example State Management**:
```bash
# Check key state
aws kms describe-key --key-id alias/my-key --query 'KeyMetadata.KeyState'

# Disable key
aws kms disable-key --key-id alias/my-key

# Enable key
aws kms enable-key --key-id alias/my-key

# Schedule key deletion (30 days)
aws kms schedule-key-deletion --key-id alias/my-key --pending-window-in-days 30

# Cancel key deletion
aws kms cancel-key-deletion --key-id alias/my-key
```

### 4. Key Aliases

#### What are Aliases?
- Human-readable names for KMS keys
- Easier to remember than key IDs
- Can be updated to point to different keys
- Useful for key rotation scenarios

#### Alias Naming Rules:
- Must start with `alias/`
- Cannot start with `alias/aws/` (reserved)
- 1-256 characters long
- Can contain letters, numbers, hyphens, and underscores

**Example Alias Management**:
```bash
# Create alias
aws kms create-alias \
  --alias-name alias/my-application-key \
  --target-key-id 12345678-1234-1234-1234-123456789012

# List aliases
aws kms list-aliases

# Update alias to point to new key
aws kms update-alias \
  --alias-name alias/my-application-key \
  --target-key-id 87654321-4321-4321-4321-210987654321

# Delete alias
aws kms delete-alias --alias-name alias/my-application-key
```

---

## Creating & Managing KMS Keys

### 1. Creating Keys via AWS CLI

#### Basic Symmetric Key Creation:
```bash
# Create basic symmetric key
KEY_ID=$(aws kms create-key \
  --description "Application data encryption key" \
  --key-usage ENCRYPT_DECRYPT \
  --key-spec SYMMETRIC_DEFAULT \
  --query 'KeyMetadata.KeyId' \
  --output text)

echo "Created key: $KEY_ID"

# Create alias for the key
aws kms create-alias \
  --alias-name alias/app-data-key \
  --target-key-id $KEY_ID
```

#### Advanced Key Creation with Tags:
```bash
# Create key with comprehensive configuration
aws kms create-key \
  --description "Production database encryption key" \
  --key-usage ENCRYPT_DECRYPT \
  --key-spec SYMMETRIC_DEFAULT \
  --origin AWS_KMS \
  --tags '[
    {
      "TagKey": "Environment",
      "TagValue": "Production"
    },
    {
      "TagKey": "Application", 
      "TagValue": "Database"
    },
    {
      "TagKey": "Owner",
      "TagValue": "DBA-Team"
    },
    {
      "TagKey": "CostCenter",
      "TagValue": "IT-Infrastructure"
    }
  ]'
```

#### Asymmetric Key Creation:
```bash
# Create RSA key for signing
aws kms create-key \
  --description "Code signing key" \
  --key-usage SIGN_VERIFY \
  --key-spec RSA_2048 \
  --tags '[
    {
      "TagKey": "Purpose",
      "TagValue": "CodeSigning"
    }
  ]'

# Create ECC key for encryption
aws kms create-key \
  --description "Client-side encryption key" \
  --key-usage ENCRYPT_DECRYPT \
  --key-spec ECC_NIST_P256 \
  --tags '[
    {
      "TagKey": "Purpose", 
      "TagValue": "ClientEncryption"
    }
  ]'
```

### 2. Creating Keys via Terraform

#### Basic Key Configuration:
```hcl
# terraform/kms.tf

# Customer managed key
resource "aws_kms_key" "app_data" {
  description             = "Application data encryption key"
  key_usage              = "ENCRYPT_DECRYPT"
  key_spec               = "SYMMETRIC_DEFAULT"
  deletion_window_in_days = 30
  enable_key_rotation     = true

  tags = {
    Name        = "app-data-encryption-key"
    Environment = "production"
    Application = "web-app"
    Owner       = "devops-team"
  }
}

# Key alias
resource "aws_kms_alias" "app_data" {
  name          = "alias/app-data-key"
  target_key_id = aws_kms_key.app_data.key_id
}

# Output key information
output "kms_key_id" {
  description = "KMS Key ID"
  value       = aws_kms_key.app_data.key_id
}

output "kms_key_arn" {
  description = "KMS Key ARN"
  value       = aws_kms_key.app_data.arn
}

output "kms_alias_name" {
  description = "KMS Key Alias"
  value       = aws_kms_alias.app_data.name
}
```

#### Multi-Environment Key Setup:
```hcl
# terraform/modules/kms/main.tf

variable "environment" {
  description = "Environment name"
  type        = string
}

variable "application" {
  description = "Application name"
  type        = string
}

variable "key_rotation" {
  description = "Enable automatic key rotation"
  type        = bool
  default     = true
}

# Environment-specific key
resource "aws_kms_key" "main" {
  description             = "${var.application} ${var.environment} encryption key"
  key_usage              = "ENCRYPT_DECRYPT"
  key_spec               = "SYMMETRIC_DEFAULT"
  deletion_window_in_days = var.environment == "production" ? 30 : 7
  enable_key_rotation     = var.key_rotation

  tags = {
    Name        = "${var.application}-${var.environment}-key"
    Environment = var.environment
    Application = var.application
    ManagedBy   = "terraform"
  }
}

resource "aws_kms_alias" "main" {
  name          = "alias/${var.application}-${var.environment}-key"
  target_key_id = aws_kms_key.main.key_id
}

# Key policy (will be covered in next section)
resource "aws_kms_key_policy" "main" {
  key_id = aws_kms_key.main.id
  policy = data.aws_iam_policy_document.kms_key_policy.json
}

# Usage in root module
module "production_kms" {
  source = "./modules/kms"
  
  environment   = "production"
  application   = "ecommerce"
  key_rotation  = true
}

module "staging_kms" {
  source = "./modules/kms"
  
  environment   = "staging" 
  application   = "ecommerce"
  key_rotation  = false
}
```

### 3. Creating Keys via CloudFormation

#### Basic CloudFormation Template:
```yaml
# cloudformation/kms-key.yaml
AWSTemplateFormatVersion: '2010-09-09'
Description: 'KMS Key for application encryption'

Parameters:
  Environment:
    Type: String
    Default: production
    AllowedValues: [production, staging, development]
    Description: Environment name
  
  Application:
    Type: String
    Default: web-app
    Description: Application name
  
  EnableKeyRotation:
    Type: String
    Default: 'true'
    AllowedValues: ['true', 'false']
    Description: Enable automatic key rotation

Resources:
  # KMS Key
  ApplicationKey:
    Type: AWS::KMS::Key
    Properties:
      Description: !Sub '${Application} ${Environment} encryption key'
      KeyUsage: ENCRYPT_DECRYPT
      KeySpec: SYMMETRIC_DEFAULT
      KeyRotationStatus: !Ref EnableKeyRotation
      PendingWindowInDays: !If [IsProduction, 30, 7]
      KeyPolicy:
        Version: '2012-10-17'
        Statement:
          - Sid: Enable IAM User Permissions
            Effect: Allow
            Principal:
              AWS: !Sub 'arn:aws:iam::${AWS::AccountId}:root'
            Action: 'kms:*'
            Resource: '*'
          - Sid: Allow use of the key for encryption
            Effect: Allow
            Principal:
              AWS: !Sub 'arn:aws:iam::${AWS::AccountId}:role/ApplicationRole'
            Action:
              - kms:Encrypt
              - kms:Decrypt
              - kms:ReEncrypt*
              - kms:GenerateDataKey*
              - kms:DescribeKey
            Resource: '*'
      Tags:
        - Key: Name
          Value: !Sub '${Application}-${Environment}-key'
        - Key: Environment
          Value: !Ref Environment
        - Key: Application
          Value: !Ref Application

  # Key Alias
  ApplicationKeyAlias:
    Type: AWS::KMS::Alias
    Properties:
      AliasName: !Sub 'alias/${Application}-${Environment}-key'
      TargetKeyId: !Ref ApplicationKey

Conditions:
  IsProduction: !Equals [!Ref Environment, production]

Outputs:
  KeyId:
    Description: KMS Key ID
    Value: !Ref ApplicationKey
    Export:
      Name: !Sub '${AWS::StackName}-KeyId'
  
  KeyArn:
    Description: KMS Key ARN
    Value: !GetAtt ApplicationKey.Arn
    Export:
      Name: !Sub '${AWS::StackName}-KeyArn'
  
  KeyAlias:
    Description: KMS Key Alias
    Value: !Ref ApplicationKeyAlias
    Export:
      Name: !Sub '${AWS::StackName}-KeyAlias'
```

### 4. Key Import (External Key Material)

#### When to Use External Key Material:
- Compliance requirements for key generation
- Integration with existing key management systems
- Need for key material backup outside AWS
- Regulatory requirements for key control

#### Import Process:

**Step 1: Create Key for Import**
```bash
# Create key without key material
KEY_ID=$(aws kms create-key \
  --description "Key with external material" \
  --key-usage ENCRYPT_DECRYPT \
  --origin EXTERNAL \
  --query 'KeyMetadata.KeyId' \
  --output text)

echo "Created key for import: $KEY_ID"
```

**Step 2: Get Import Parameters**
```bash
# Get import parameters
aws kms get-parameters-for-import \
  --key-id $KEY_ID \
  --wrapping-algorithm RSAES_PKCS1_V1_5 \
  --wrapping-key-spec RSA_2048 \
  --query '{ImportToken:ImportToken,PublicKey:PublicKey}' \
  --output json > import-parameters.json

# Extract public key for wrapping
cat import-parameters.json | jq -r '.PublicKey' | base64 -d > public-key.bin
```

**Step 3: Generate and Wrap Key Material**
```bash
# Generate 256-bit key material
openssl rand -out key-material.bin 32

# Wrap key material with public key
openssl rsautl -encrypt \
  -in key-material.bin \
  -out wrapped-key-material.bin \
  -inkey public-key.bin \
  -keyform DER \
  -pubin \
  -pkcs

# Encode for import
base64 wrapped-key-material.bin > wrapped-key-material.b64
```

**Step 4: Import Key Material**
```bash
# Import the wrapped key material
aws kms import-key-material \
  --key-id $KEY_ID \
  --import-token $(cat import-parameters.json | jq -r '.ImportToken') \
  --encrypted-key-material fileb://wrapped-key-material.bin \
  --expiration-model KEY_MATERIAL_DOES_NOT_EXPIRE

echo "Key material imported successfully"
```

**Step 5: Verify Import**
```bash
# Check key state
aws kms describe-key --key-id $KEY_ID --query 'KeyMetadata.KeyState'

# Test encryption
aws kms encrypt \
  --key-id $KEY_ID \
  --plaintext "Hello, World!" \
  --query 'CiphertextBlob' \
  --output text
```

---

## Key Policies & Access Control

### 1. Understanding Key Policies

#### Key Policy vs IAM Policy:
- **Key Policy**: Resource-based policy attached to KMS key
- **IAM Policy**: Identity-based policy attached to users/roles
- **Both Required**: User needs permissions in both policies
- **Key Policy is Primary**: Defines who can access the key

#### Default Key Policy:
```json
{
  "Version": "2012-10-17",
  "Id": "key-policy-1",
  "Statement": [
    {
      "Sid": "Enable IAM User Permissions",
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::123456789012:root"
      },
      "Action": "kms:*",
      "Resource": "*"
    }
  ]
}
```

**What this means**:
- Gives the AWS account root user full access
- Allows IAM policies to grant access to the key
- Without this, IAM policies alone cannot grant access

### 2. Key Policy Components

#### Principal Types:
```json
{
  "Principal": {
    // AWS Account
    "AWS": "arn:aws:iam::123456789012:root",
    
    // IAM User
    "AWS": "arn:aws:iam::123456789012:user/john",
    
    // IAM Role
    "AWS": "arn:aws:iam::123456789012:role/ApplicationRole",
    
    // Multiple principals
    "AWS": [
      "arn:aws:iam::123456789012:user/alice",
      "arn:aws:iam::123456789012:role/LambdaRole"
    ],
    
    // AWS Service
    "Service": "s3.amazonaws.com",
    
    // Federated user
    "Federated": "arn:aws:iam::123456789012:saml-provider/ExampleProvider"
  }
}
```

#### Common KMS Actions:
```json
{
  "Action": [
    // Key management actions
    "kms:Create*",
    "kms:Describe*",
    "kms:Enable*",
    "kms:List*",
    "kms:Put*",
    "kms:Update*",
    "kms:Revoke*",
    "kms:Disable*",
    "kms:Get*",
    "kms:Delete*",
    "kms:ScheduleKeyDeletion",
    "kms:CancelKeyDeletion",
    
    // Cryptographic actions
    "kms:Encrypt",
    "kms:Decrypt", 
    "kms:ReEncrypt*",
    "kms:GenerateDataKey*",
    "kms:CreateGrant",
    "kms:ListGrants",
    "kms:RevokeGrant",
    
    // Signing actions (asymmetric keys)
    "kms:Sign",
    "kms:Verify",
    "kms:GetPublicKey"
  ]
}
```

### 3. Real-World Key Policy Examples

#### Example 1: Application-Specific Key Policy
```json
{
  "Version": "2012-10-17",
  "Id": "application-key-policy",
  "Statement": [
    {
      "Sid": "Enable IAM User Permissions",
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::123456789012:root"
      },
      "Action": "kms:*",
      "Resource": "*"
    },
    {
      "Sid": "Allow application role to use the key",
      "Effect": "Allow",
      "Principal": {
        "AWS": [
          "arn:aws:iam::123456789012:role/WebApplicationRole",
          "arn:aws:iam::123456789012:role/BackgroundJobRole"
        ]
      },
      "Action": [
        "kms:Encrypt",
        "kms:Decrypt",
        "kms:ReEncrypt*",
        "kms:GenerateDataKey*",
        "kms:DescribeKey"
      ],
      "Resource": "*"
    },
    {
      "Sid": "Allow administrators to manage the key",
      "Effect": "Allow",
      "Principal": {
        "AWS": [
          "arn:aws:iam::123456789012:user/admin1",
          "arn:aws:iam::123456789012:role/AdminRole"
        ]
      },
      "Action": [
        "kms:Create*",
        "kms:Describe*",
        "kms:Enable*",
        "kms:List*",
        "kms:Put*",
        "kms:Update*",
        "kms:Revoke*",
        "kms:Disable*",
        "kms:Get*",
        "kms:Delete*",
        "kms:ScheduleKeyDeletion",
        "kms:CancelKeyDeletion"
      ],
      "Resource": "*"
    },
    {
      "Sid": "Allow CloudTrail to describe key",
      "Effect": "Allow",
      "Principal": {
        "Service": "cloudtrail.amazonaws.com"
      },
      "Action": [
        "kms:DescribeKey",
        "kms:GetKeyPolicy"
      ],
      "Resource": "*"
    }
  ]
}
```

#### Example 2: Cross-Account Access Policy
```json
{
  "Version": "2012-10-17",
  "Id": "cross-account-key-policy",
  "Statement": [
    {
      "Sid": "Enable IAM User Permissions",
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::123456789012:root"
      },
      "Action": "kms:*",
      "Resource": "*"
    },
    {
      "Sid": "Allow cross-account access",
      "Effect": "Allow",
      "Principal": {
        "AWS": [
          "arn:aws:iam::987654321098:root",
          "arn:aws:iam::111122223333:role/CrossAccountRole"
        ]
      },
      "Action": [
        "kms:Encrypt",
        "kms:Decrypt",
        "kms:ReEncrypt*",
        "kms:GenerateDataKey*",
        "kms:DescribeKey"
      ],
      "Resource": "*",
      "Condition": {
        "StringEquals": {
          "kms:ViaService": [
            "s3.us-east-1.amazonaws.com",
            "s3.us-west-2.amazonaws.com"
          ]
        }
      }
    },
    {
      "Sid": "Restrict to specific encryption context",
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::987654321098:role/DataProcessingRole"
      },
      "Action": [
        "kms:Encrypt",
        "kms:Decrypt",
        "kms:GenerateDataKey*"
      ],
      "Resource": "*",
      "Condition": {
        "StringEquals": {
          "kms:EncryptionContext:Department": "Finance",
          "kms:EncryptionContext:Project": "DataAnalytics"
        }
      }
    }
  ]
}
```

#### Example 3: Time-Based Access Policy
```json
{
  "Version": "2012-10-17",
  "Id": "time-based-key-policy",
  "Statement": [
    {
      "Sid": "Enable IAM User Permissions",
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::123456789012:root"
      },
      "Action": "kms:*",
      "Resource": "*"
    },
    {
      "Sid": "Allow access during business hours only",
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::123456789012:role/BusinessHoursRole"
      },
      "Action": [
        "kms:Encrypt",
        "kms:Decrypt",
        "kms:GenerateDataKey*"
      ],
      "Resource": "*",
      "Condition": {
        "DateGreaterThan": {
          "aws:CurrentTime": "08:00Z"
        },
        "DateLessThan": {
          "aws:CurrentTime": "18:00Z"
        },
        "ForAllValues:StringEquals": {
          "aws:RequestedRegion": ["us-east-1", "us-west-2"]
        }
      }
    },
    {
      "Sid": "Emergency access outside business hours",
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::123456789012:role/EmergencyRole"
      },
      "Action": [
        "kms:Decrypt",
        "kms:DescribeKey"
      ],
      "Resource": "*",
      "Condition": {
        "Bool": {
          "aws:MultiFactorAuthPresent": "true"
        }
      }
    }
  ]
}
```

### 4. Applying Key Policies

#### Via AWS CLI:
```bash
# Create policy document
cat > key-policy.json << 'EOF'
{
  "Version": "2012-10-17",
  "Id": "key-policy-1",
  "Statement": [
    {
      "Sid": "Enable IAM User Permissions",
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::123456789012:root"
      },
      "Action": "kms:*",
      "Resource": "*"
    },
    {
      "Sid": "Allow application access",
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::123456789012:role/ApplicationRole"
      },
      "Action": [
        "kms:Encrypt",
        "kms:Decrypt",
        "kms:ReEncrypt*",
        "kms:GenerateDataKey*",
        "kms:DescribeKey"
      ],
      "Resource": "*"
    }
  ]
}
EOF

# Apply policy to key
aws kms put-key-policy \
  --key-id alias/my-application-key \
  --policy-name default \
  --policy file://key-policy.json

# Verify policy
aws kms get-key-policy \
  --key-id alias/my-application-key \
  --policy-name default \
  --output text
```

#### Via Terraform:
```hcl
# Define policy document
data "aws_iam_policy_document" "kms_key_policy" {
  statement {
    sid    = "Enable IAM User Permissions"
    effect = "Allow"
    
    principals {
      type        = "AWS"
      identifiers = ["arn:aws:iam::${data.aws_caller_identity.current.account_id}:root"]
    }
    
    actions   = ["kms:*"]
    resources = ["*"]
  }
  
  statement {
    sid    = "Allow application access"
    effect = "Allow"
    
    principals {
      type        = "AWS"
      identifiers = [
        aws_iam_role.application.arn,
        aws_iam_role.background_job.arn
      ]
    }
    
    actions = [
      "kms:Encrypt",
      "kms:Decrypt", 
      "kms:ReEncrypt*",
      "kms:GenerateDataKey*",
      "kms:DescribeKey"
    ]
    
    resources = ["*"]
  }
  
  statement {
    sid    = "Allow CloudWatch Logs"
    effect = "Allow"
    
    principals {
      type        = "Service"
      identifiers = ["logs.amazonaws.com"]
    }
    
    actions = [
      "kms:Encrypt",
      "kms:Decrypt",
      "kms:ReEncrypt*",
      "kms:GenerateDataKey*",
      "kms:DescribeKey"
    ]
    
    resources = ["*"]
    
    condition {
      test     = "ArnEquals"
      variable = "kms:EncryptionContext:aws:logs:arn"
      values   = ["arn:aws:logs:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:log-group:/aws/lambda/*"]
    }
  }
}

# Apply policy to key
resource "aws_kms_key_policy" "example" {
  key_id = aws_kms_key.example.id
  policy = data.aws_iam_policy_document.kms_key_policy.json
}
```

### 5. IAM Policies for KMS

#### User Policy for Key Usage:
```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "AllowKeyUsage",
      "Effect": "Allow",
      "Action": [
        "kms:Encrypt",
        "kms:Decrypt",
        "kms:ReEncrypt*",
        "kms:GenerateDataKey*",
        "kms:DescribeKey"
      ],
      "Resource": [
        "arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012",
        "arn:aws:kms:us-east-1:123456789012:key/87654321-4321-4321-4321-210987654321"
      ]
    },
    {
      "Sid": "AllowKeyListing",
      "Effect": "Allow",
      "Action": [
        "kms:ListKeys",
        "kms:ListAliases"
      ],
      "Resource": "*"
    }
  ]
}
```

#### Administrator Policy:
```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "AllowKeyManagement",
      "Effect": "Allow",
      "Action": [
        "kms:Create*",
        "kms:Describe*",
        "kms:Enable*",
        "kms:List*",
        "kms:Put*",
        "kms:Update*",
        "kms:Revoke*",
        "kms:Disable*",
        "kms:Get*",
        "kms:Delete*",
        "kms:TagResource",
        "kms:UntagResource",
        "kms:ScheduleKeyDeletion",
        "kms:CancelKeyDeletion"
      ],
      "Resource": "*"
    },
    {
      "Sid": "AllowKeyUsage",
      "Effect": "Allow",
      "Action": [
        "kms:Encrypt",
        "kms:Decrypt",
        "kms:ReEncrypt*",
        "kms:GenerateDataKey*",
        "kms:CreateGrant",
        "kms:ListGrants",
        "kms:RevokeGrant"
      ],
      "Resource": "*"
    }
  ]
}
```

This comprehensive guide covers KMS fundamentals, key types, creation methods, and access control. The guide includes practical examples and real-world scenarios for implementing KMS in production environments.

Would you like me to continue with the remaining sections covering encryption operations, key rotation, AWS service integration, and advanced topics like multi-region keys and monitoring?